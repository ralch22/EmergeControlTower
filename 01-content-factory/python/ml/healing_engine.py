"""
Healing Engine for Agent Self-Recovery
Combines anomaly detection with automated healing actions
"""
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

from pydantic import BaseModel, Field

from .anomaly_detector import AnomalyDetector, AnomalyResult, MetricType, SuggestedAction
from .metrics_collector import MetricsCollector

logger = logging.getLogger(__name__)


class AlertSeverity(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertStatus(str, Enum):
    ACTIVE = "active"
    ACKNOWLEDGED = "acknowledged"
    RESOLVED = "resolved"
    SUPPRESSED = "suppressed"


class HealingAlert(BaseModel):
    """Alert generated by the healing engine"""
    id: str = Field(default_factory=lambda: f"alert_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}")
    agent_slug: str
    metric_type: str
    severity: AlertSeverity
    status: AlertStatus = AlertStatus.ACTIVE
    current_value: float
    expected_value: float
    anomaly_score: float
    suggested_action: str
    action_description: str
    confidence: float
    created_at: datetime = Field(default_factory=datetime.now)
    context: Dict[str, Any] = Field(default_factory=dict)


class HealingEngine:
    """
    Healing engine that combines anomaly detection with action generation.
    
    Analyzes agent health, detects anomalies, and generates healing alerts
    with suggested remediation actions.
    """
    
    ACTION_DESCRIPTIONS = {
        SuggestedAction.RETRAIN: "Model performance has degraded. Recommend retraining with recent data.",
        SuggestedAction.RESTART: "Service experiencing failures. Recommend restarting the agent.",
        SuggestedAction.INVESTIGATE: "Unusual behavior detected. Manual investigation recommended.",
        SuggestedAction.SCALE_DOWN: "Resources underutilized. Consider scaling down to reduce costs.",
        SuggestedAction.SCALE_UP: "Performance degraded due to load. Consider scaling up resources.",
        SuggestedAction.NO_ACTION: "Metrics within normal range. No action required.",
    }
    
    SEVERITY_THRESHOLDS = {
        "critical": -0.8,
        "high": -0.5,
        "medium": -0.2,
        "low": 0.0,
    }
    
    def __init__(
        self,
        detector: Optional[AnomalyDetector] = None,
        collector: Optional[MetricsCollector] = None,
    ):
        """
        Initialize the healing engine.
        
        Args:
            detector: AnomalyDetector instance (created if not provided)
            collector: MetricsCollector instance (created if not provided)
        """
        self.detector = detector or AnomalyDetector()
        self.collector = collector or MetricsCollector()
        
        self._active_alerts: Dict[str, HealingAlert] = {}
        self._alert_history: List[HealingAlert] = []
        
        logger.info("HealingEngine initialized")
    
    def analyze_agent_health(
        self,
        agent_slug: str,
        hours: int = 24,
    ) -> List[HealingAlert]:
        """
        Analyze an agent's health and generate healing alerts.
        
        Args:
            agent_slug: Unique identifier for the agent
            hours: Number of hours of recent data to analyze
            
        Returns:
            List of HealingAlert objects for detected issues
        """
        alerts: List[HealingAlert] = []
        
        metrics = self.collector.get_agent_metrics(agent_slug, hours=hours)
        
        if not metrics:
            logger.warning(f"No metrics found for agent {agent_slug}")
            return alerts
        
        training_metrics = self.collector.export_for_training(agent_slug, hours=168)
        if training_metrics:
            self.detector.train(training_metrics)
        
        anomaly_results = self.detector.detect_anomalies(metrics)
        
        for result in anomaly_results:
            if result.is_anomaly:
                alert = self.format_alert(result, agent_slug)
                alerts.append(alert)
                
                alert_key = f"{agent_slug}:{result.metric_type.value}"
                self._active_alerts[alert_key] = alert
                self._alert_history.append(alert)
        
        logger.info(
            f"Health analysis for {agent_slug}: "
            f"{len(metrics)} metrics analyzed, {len(alerts)} alerts generated"
        )
        
        return alerts
    
    def run_full_scan(self) -> List[HealingAlert]:
        """
        Run health analysis for all registered agents.
        
        Returns:
            List of HealingAlert objects for all detected issues
        """
        all_alerts: List[HealingAlert] = []
        
        agent_slugs = self.collector.get_all_agent_slugs()
        
        if not agent_slugs:
            logger.warning("No agents registered for health scan")
            return all_alerts
        
        logger.info(f"Running full health scan for {len(agent_slugs)} agents")
        
        for agent_slug in agent_slugs:
            try:
                alerts = self.analyze_agent_health(agent_slug)
                all_alerts.extend(alerts)
            except Exception as e:
                logger.error(f"Error analyzing agent {agent_slug}: {e}")
                continue
        
        severity_counts = {}
        for alert in all_alerts:
            severity_counts[alert.severity.value] = severity_counts.get(alert.severity.value, 0) + 1
        
        logger.info(
            f"Full scan complete: {len(all_alerts)} alerts across {len(agent_slugs)} agents. "
            f"Severity breakdown: {severity_counts}"
        )
        
        return all_alerts
    
    def format_alert(
        self,
        anomaly: AnomalyResult,
        agent_slug: str,
    ) -> HealingAlert:
        """
        Format an anomaly result as a healing alert.
        
        Args:
            anomaly: AnomalyResult from the detector
            agent_slug: Unique identifier for the agent
            
        Returns:
            Formatted HealingAlert
        """
        severity = self._calculate_severity(anomaly.anomaly_score)
        
        action_description = self.ACTION_DESCRIPTIONS.get(
            anomaly.suggested_action,
            "Unknown action recommended."
        )
        
        context = {
            **anomaly.context,
            "detection_timestamp": anomaly.timestamp.isoformat(),
            "deviation_percent": self._calculate_deviation(
                anomaly.current_value,
                anomaly.expected_value,
            ),
        }
        
        return HealingAlert(
            agent_slug=agent_slug,
            metric_type=anomaly.metric_type.value,
            severity=severity,
            current_value=anomaly.current_value,
            expected_value=anomaly.expected_value,
            anomaly_score=anomaly.anomaly_score,
            suggested_action=anomaly.suggested_action.value,
            action_description=action_description,
            confidence=anomaly.confidence,
            context=context,
        )
    
    def _calculate_severity(self, anomaly_score: float) -> AlertSeverity:
        """Calculate alert severity based on anomaly score."""
        if anomaly_score <= self.SEVERITY_THRESHOLDS["critical"]:
            return AlertSeverity.CRITICAL
        elif anomaly_score <= self.SEVERITY_THRESHOLDS["high"]:
            return AlertSeverity.HIGH
        elif anomaly_score <= self.SEVERITY_THRESHOLDS["medium"]:
            return AlertSeverity.MEDIUM
        else:
            return AlertSeverity.LOW
    
    def _calculate_deviation(
        self,
        current: float,
        expected: float,
    ) -> float:
        """Calculate percentage deviation from expected value."""
        if expected == 0:
            return 100.0 if current != 0 else 0.0
        return ((current - expected) / abs(expected)) * 100
    
    def get_active_alerts(
        self,
        agent_slug: Optional[str] = None,
        severity: Optional[AlertSeverity] = None,
    ) -> List[HealingAlert]:
        """
        Get currently active alerts.
        
        Args:
            agent_slug: Optional filter by agent
            severity: Optional filter by severity
            
        Returns:
            List of active HealingAlert objects
        """
        alerts = list(self._active_alerts.values())
        
        if agent_slug:
            alerts = [a for a in alerts if a.agent_slug == agent_slug]
        
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        
        return sorted(alerts, key=lambda a: a.created_at, reverse=True)
    
    def get_alert_history(
        self,
        agent_slug: Optional[str] = None,
        hours: int = 24,
        limit: int = 100,
    ) -> List[HealingAlert]:
        """
        Get historical alerts.
        
        Args:
            agent_slug: Optional filter by agent
            hours: Number of hours to look back
            limit: Maximum number of alerts to return
            
        Returns:
            List of HealingAlert objects
        """
        from datetime import timedelta
        
        cutoff = datetime.now() - timedelta(hours=hours)
        
        alerts = [
            a for a in self._alert_history
            if a.created_at >= cutoff
        ]
        
        if agent_slug:
            alerts = [a for a in alerts if a.agent_slug == agent_slug]
        
        alerts = sorted(alerts, key=lambda a: a.created_at, reverse=True)
        
        return alerts[:limit]
    
    def acknowledge_alert(self, alert_id: str) -> bool:
        """
        Acknowledge an active alert.
        
        Args:
            alert_id: ID of the alert to acknowledge
            
        Returns:
            True if alert was found and acknowledged
        """
        for key, alert in self._active_alerts.items():
            if alert.id == alert_id:
                alert.status = AlertStatus.ACKNOWLEDGED
                logger.info(f"Alert {alert_id} acknowledged")
                return True
        
        return False
    
    def resolve_alert(self, alert_id: str) -> bool:
        """
        Resolve and remove an active alert.
        
        Args:
            alert_id: ID of the alert to resolve
            
        Returns:
            True if alert was found and resolved
        """
        for key, alert in list(self._active_alerts.items()):
            if alert.id == alert_id:
                alert.status = AlertStatus.RESOLVED
                del self._active_alerts[key]
                logger.info(f"Alert {alert_id} resolved")
                return True
        
        return False
    
    def get_health_summary(self, agent_slug: str) -> Dict[str, Any]:
        """
        Get a health summary for an agent.
        
        Args:
            agent_slug: Unique identifier for the agent
            
        Returns:
            Dictionary with health summary
        """
        active_alerts = self.get_active_alerts(agent_slug=agent_slug)
        metrics_summary = self.collector.get_metrics_summary(agent_slug)
        
        severity_counts = {s.value: 0 for s in AlertSeverity}
        for alert in active_alerts:
            severity_counts[alert.severity.value] += 1
        
        if severity_counts["critical"] > 0:
            overall_health = "critical"
        elif severity_counts["high"] > 0:
            overall_health = "degraded"
        elif severity_counts["medium"] > 0:
            overall_health = "warning"
        else:
            overall_health = "healthy"
        
        return {
            "agent_slug": agent_slug,
            "overall_health": overall_health,
            "active_alerts_count": len(active_alerts),
            "severity_breakdown": severity_counts,
            "metrics_summary": metrics_summary,
            "last_scan": datetime.now().isoformat(),
        }
