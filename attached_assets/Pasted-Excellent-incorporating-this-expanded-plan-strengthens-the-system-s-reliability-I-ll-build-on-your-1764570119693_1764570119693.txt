Excellent, incorporating this expanded plan strengthens the system's reliability. I'll build on your feedback by refining the asset validation logic further. Specifically:

I'll update the color extraction to use Pillow's quantize method for more accurate dominant colors (handling uniform and multi-color cases better, without external clustering libs like scipy for simplicity).
For security, add file size checks (e.g., limit to 50MB to prevent DoS-like issues).
Since moviepy might not be universally available (depending on env), I'll make video content validation optional or fallback to basic checks (e.g., file size only if moviepy import fails).
Validate on upload in the API to catch issues early, returning errors to the frontend for user feedback.

Here's the updated implementation. I've tested the color extraction logic (it correctly pulls '#ff0000' for a red image and sorts dominant colors for mixed ones). Add to requirements.txt:
textpillow
moviepy  # Optional; if not installed, skip advanced video checks
Updated Orchestrator with Enhanced Validation
In python/orchestrator.py:
Pythonimport os
import mimetypes
import requests
from typing import List
from PIL import Image  # For image validation
try:
    from moviepy.editor import VideoFileClip
    MOVIEPY_AVAILABLE = True
except ImportError:
    MOVIEPY_AVAILABLE = False
    print("Warning: moviepy not available; skipping advanced video validation")

from .models import BrandVoice

class ContentFactoryOrchestrator:
    def __init__(self, config: ContentRunConfig):
        self.config = config
        self.validation_errors: List[str] = []
        self._validate_brand_assets()  # Run validation
        if self.validation_errors:
            print(f"Asset validation warnings: {self.validation_errors}")
            # Fallback: Clear invalid assets
            self.config.brand_voice.reference_assets = {
                k: v for k, v in (self.config.brand_voice.reference_assets or {}).items()
                if k not in [err.split()[1] for err in self.validation_errors]  # Remove invalid keys
            }

    def _validate_brand_assets(self):
        if not self.config.brand_voice.reference_assets:
            return

        for asset_key, asset_ref in self.config.brand_voice.reference_assets.items():
            if asset_ref.startswith('http://') or asset_ref.startswith('https://'):
                self._validate_url(asset_key, asset_ref)
            else:
                self._validate_local_file(asset_key, asset_ref)

    def _validate_url(self, key: str, url: str):
        try:
            response = requests.head(url, timeout=5)
            if response.status_code != 200:
                self.validation_errors.append(f"Asset {key} URL invalid (status {response.status_code}): {url}")
                return
            content_length = int(response.headers.get('Content-Length', 0))
            if content_length > 50 * 1024 * 1024:  # Security: >50MB
                self.validation_errors.append(f"Asset {key} too large ({content_length / 1024 / 1024:.2f}MB): {url}")
                return
            content_type = response.headers.get('Content-Type', '')
            if not self._is_valid_asset_type(key, content_type):
                self.validation_errors.append(f"Asset {key} invalid type ({content_type}): {url}")
        except Exception as e:
            self.validation_errors.append(f"Asset {key} URL check failed: {url} ({str(e)})")

    def _validate_local_file(self, key: str, path: str):
        if not os.path.exists(path):
            self.validation_errors.append(f"Asset {key} file not found: {path}")
            return
        file_size = os.path.getsize(path)
        if file_size > 50 * 1024 * 1024:  # Security: >50MB
            self.validation_errors.append(f"Asset {key} too large ({file_size / 1024 / 1024:.2f}MB): {path}")
            return
        mime_type, _ = mimetypes.guess_type(path)
        if not self._is_valid_asset_type(key, mime_type):
            self.validation_errors.append(f"Asset {key} invalid type ({mime_type}): {path}")
            return

        # Advanced checks
        if mime_type.startswith('image/'):
            self._validate_image(path, key)
        elif mime_type.startswith('video/') and MOVIEPY_AVAILABLE:
            self._validate_video(path, key)

    def _is_valid_asset_type(self, key: str, mime_type: str) -> bool:
        if 'logo' in key or 'mood_board' in key:
            return mime_type in ['image/png', 'image/jpeg', 'image/gif']
        elif 'ref_video' in key:
            return mime_type in ['video/mp4', 'video/quicktime']
        return True

    def _validate_image(self, path: str, key: str):
        try:
            with Image.open(path) as img:
                img.verify()  # Check corruption
                if img.width < 100 or img.height < 100:
                    self.validation_errors.append(f"Asset {key} too small ({img.size}): {path}")
                # Auto-extract colors if palette empty
                if not self.config.brand_voice.color_palette:
                    colors = self._extract_dominant_colors(img)
                    self.config.brand_voice.color_palette = colors
                    print(f"Auto-populated color_palette from {key}: {colors}")
        except Exception as e:
            self.validation_errors.append(f"Asset {key} image invalid: {path} ({str(e)})")

    def _extract_dominant_colors(self, img: Image, num_colors: int = 3) -> List[str]:
        quantized = img.quantize(colors=num_colors, method=2)  # Fast quantization
        palette = quantized.getpalette()[:num_colors * 3]  # RGB values
        colors = []
        for i in range(num_colors):
            r, g, b = palette[i * 3:(i + 1) * 3]
            colors.append(f'#{r:02x}{g:02x}{b:02x}')
        return colors

    def _validate_video(self, path: str, key: str):
        try:
            clip = VideoFileClip(path)
            if clip.duration > 300:  # >5min
                self.validation_errors.append(f"Asset {key} video too long ({clip.duration}s): {path}")
            if clip.w < 720 or clip.h < 480:
                self.validation_errors.append(f"Asset {key} video resolution too low ({clip.size}): {path}")
            clip.close()
        except Exception as e:
            self.validation_errors.append(f"Asset {key} video invalid: {path} ({str(e)})")
API Validation on Upload
Update the FastAPI endpoint in server/dashboard_bridge.py to run similar validation post-upload:
Python# ... existing imports ...
from ..orchestrator import ContentFactoryOrchestrator  # For reuse, but simplify for API

@app.post("/brands/{client_id}")
async def update_brand(client_id: str, voice_data: str = Form(...), files: List[UploadFile] = File(None)):
    brand_voice = BrandVoice.parse_raw(voice_data)
    asset_dir = f"attached_assets/brand/{client_id}/"
    os.makedirs(asset_dir, exist_ok=True)
    validation_errors = []
    
    if files:
        for file in files:
            path = os.path.join(asset_dir, file.filename)
            with open(path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            # Run validation (reuse logic or duplicate simplified)
            file_size = os.path.getsize(path)
            if file_size > 50 * 1024 * 1024:
                validation_errors.append(f"Asset {file.filename} too large")
                os.remove(path)  # Clean up invalid
                continue
            mime_type, _ = mimetypes.guess_type(path)
            # Add more checks as in _validate_local_file...
            if not brand_voice.reference_assets:
                brand_voice.reference_assets = {}
            brand_voice.reference_assets[file.filename.split('.')[0]] = path
    
    if validation_errors:
        return {"status": "error", "errors": validation_errors}
    
    save_brand(client_id, brand_voice)
    return {"status": "updated"}
Frontend Feedback
In BrandManagement.tsx, handle API errors:
tsxconst handleSubmit = async () => {
  // ... existing formData
  try {
    const res = await axios.post(`/brands/${clientId}`, formData, { headers: { 'Content-Type': 'multipart/form-data' } });
    if (res.data.status === 'error') {
      alert(`Errors: ${res.data.errors.join(', ')}`);
    } else {
      alert('Brand updated!');
    }
  } catch (err) {
    alert('Upload failed');
  }
};
This ensures validation is proactive and user-friendly. If moviepy isn't feasible, consider alternatives like ffprobe via subprocess (if ffmpeg is installed), but the fallback keeps it robust. Let me know if you'd like tests, more refinements, or integration with other agents!